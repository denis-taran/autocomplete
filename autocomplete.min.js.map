{"version":3,"file":"autocomplete.min.js","sources":["autocomplete.ts"],"sourcesContent":["/*\n * https://github.com/kraaden/autocomplete\n * Copyright (c) 2016 Denys Krasnoshchok\n * MIT License\n */\n\nexport const enum EventTrigger {\n    Keyboard = 0,\n    Focus = 1\n}\n\nexport interface AutocompleteItem {\n    label?: string;\n    group?: string;\n}\n\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\n    /**\n     * Autocomplete will be attached to this element.\n     */\n    input: HTMLInputElement | HTMLTextAreaElement;\n\n    /**\n     * Provide your own container for the widget.\n     * If not specified, a new DIV element will be created.\n     */\n    container?: HTMLDivElement;\n\n    /**\n     * This method allows you to override the default rendering function for items.\n     * It must return a DIV element or undefined to skip rendering.\n     */\n    render?: (item: T, currentValue: string, index: number) => HTMLDivElement | undefined;\n\n    /**\n     * This method allows you to override the default rendering function for item groups.\n     * It must return a DIV element or undefined to skip rendering.\n     */\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\n\n    /**\n     * If specified, the autocomplete DOM element will have this class assigned to it.\n     */\n    className?: string;\n\n    /**\n     * Specify the minimum text length required to show autocomplete.\n     */\n    minLength?: number;\n\n    /**\n     * The message that will be showed when there are no suggestions that match the entered value.\n     */\n    emptyMsg?: string;\n\n    /**\n     * This method will be called when user choose an item in autocomplete. The selected item will be passed as the first parameter.\n     */\n    onSelect: (item: T, input: HTMLInputElement | HTMLTextAreaElement) => void;\n\n    /**\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\n     */\n    showOnFocus?: boolean;\n\n    /**\n     * This method will be called to prepare suggestions and then pass them to autocomplete.\n     * @param {string} text - text in the input field\n     * @param {(items: T[] | false) => void} update - a callback function that must be called after suggestions are prepared\n     * @param {EventTrigger} trigger - type of the event that triggered the fetch\n     * @param {number} cursorPos - position of the cursor in the input field\n     */\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger, cursorPos: number) => void;\n\n    /**\n     * Enforces that the fetch function will only be called once within the specified time frame (in milliseconds) and\n     * delays execution. This prevents flooding your server with AJAX requests.\n     */\n    debounceWaitMs?: number;\n\n    /**\n     * Callback for additional autocomplete customization\n     * @param {HTMLInputElement | HTMLTextAreaElement} input - input box associated with autocomplete\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\n     * @param {HTMLDivElement} container - container with suggestions\n     * @param {number} maxHeight - max height that can be used by autocomplete\n     */\n    customize?: (input: HTMLInputElement | HTMLTextAreaElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\n\n    /**\n     * Prevents automatic form submit when ENTER is pressed\n     */\n    preventSubmit?: boolean;\n\n    /**\n     * Prevents the first item in the list from being selected automatically. This option allows you\n     * to submit a custom text by pressing ENTER even when autocomplete is displayed.\n     */\n    disableAutoSelect?: boolean;\n\n    /**\n     * Keys that will be ignored and not trigger the fetch callback.\n     */\n    keysToIgnore?: Keys[];\n}\n\nexport interface AutocompleteResult {\n    destroy: () => void;\n}\n\nexport const enum Keys {\n    Enter = 13,\n    Esc = 27,\n    Up = 38,\n    Down = 40,\n    Left = 37,\n    Right = 39,\n    Shift = 16,\n    Ctrl = 17,\n    Alt = 18,\n    CapsLock = 20,\n    WindowsKey = 91,\n    Tab = 9,\n    F1 = 112,\n    F12 = 123\n}\n\nexport default function autocomplete<T extends AutocompleteItem>(settings: AutocompleteSettings<T>): AutocompleteResult {\n\n    // just an alias to minimize JS file size\n    const doc = document;\n\n    const container: HTMLDivElement = settings.container || doc.createElement(\"div\");\n    container.id = container.id || \"autocomplete-\" + uid();\n    const containerStyle = container.style;\n    const debounceWaitMs = settings.debounceWaitMs || 0;\n    const preventSubmit = settings.preventSubmit || false;\n    const disableAutoSelect = settings.disableAutoSelect || false;\n\n    let items: T[] = [];\n    let inputValue = \"\";\n    let minLen = 2;\n    const showOnFocus = settings.showOnFocus;\n    let selected: T | undefined;\n    let keypressCounter = 0;\n    let debounceTimer: number | undefined;\n\n    if (settings.minLength !== undefined) {\n        minLen = settings.minLength;\n    }\n\n    if (!settings.input) {\n        throw new Error(\"input undefined\");\n    }\n\n    const input: HTMLInputElement | HTMLTextAreaElement = settings.input;\n\n    container.className = \"autocomplete \" + (settings.className || \"\");\n    container.setAttribute(\"role\", \"listbox\");\n\n    input.setAttribute(\"role\", \"combobox\");\n    input.setAttribute(\"aria-expanded\", \"false\");\n    input.setAttribute(\"aria-autocomplete\", \"list\");\n    input.setAttribute(\"aria-controls\", container.id);\n    input.setAttribute(\"aria-owns\", container.id);\n    input.setAttribute(\"aria-activedescendant\", \"\");\n    input.setAttribute(\"aria-haspopup\", \"listbox\");\n\n    // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\n    containerStyle.position = \"absolute\";\n\n    /**\n     * Generate a unique ID\n     */\n    function uid(): string {\n        return Date.now().toString(36) + Math.random().toString(36).substring(2);\n    }\n\n    /**\n     * Detach the container from DOM\n     */\n    function detach(): void {\n        const parent = container.parentNode;\n        if (parent) {\n            parent.removeChild(container);\n        }\n    }\n\n    /**\n     * Clear debouncing timer if assigned\n     */\n    function clearDebounceTimer(): void {\n        if (debounceTimer) {\n            window.clearTimeout(debounceTimer);\n        }\n    }\n\n    /**\n     * Attach the container to DOM\n     */\n    function attach(): void {\n        if (!container.parentNode) {\n            doc.body.appendChild(container);\n        }\n    }\n\n    /**\n     * Check if container for autocomplete is displayed\n     */\n    function containerDisplayed(): boolean {\n        return !!container.parentNode;\n    }\n\n    /**\n     * Clear autocomplete state and hide container\n     */\n    function clear(): void {\n        // prevent the update call if there are pending AJAX requests\n        keypressCounter++;\n\n        items = [];\n        inputValue = \"\";\n        selected = undefined;\n        input.setAttribute(\"aria-activedescendant\", \"\");\n        input.setAttribute(\"aria-expanded\", \"false\");\n        detach();\n    }\n\n    /**\n     * Update autocomplete position\n     */\n    function updatePosition(): void {\n        if (!containerDisplayed()) {\n            return;\n        }\n\n        input.setAttribute(\"aria-expanded\", \"true\");\n\n        containerStyle.height = \"auto\";\n        containerStyle.width = input.offsetWidth + \"px\";\n\n        let maxHeight = 0;\n        let inputRect: ClientRect | DOMRect | undefined;\n\n        function calc() {\n            const docEl = doc.documentElement as HTMLElement;\n            const clientTop = docEl.clientTop || doc.body.clientTop || 0;\n            const clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;\n            const scrollTop = window.pageYOffset || docEl.scrollTop;\n            const scrollLeft = window.pageXOffset || docEl.scrollLeft;\n\n            inputRect = input.getBoundingClientRect();\n\n            const top = inputRect.top + input.offsetHeight + scrollTop - clientTop;\n            const left = inputRect.left + scrollLeft - clientLeft;\n\n            containerStyle.top = top + \"px\";\n            containerStyle.left = left + \"px\";\n\n            maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\n\n            if (maxHeight < 0) {\n                maxHeight = 0;\n            }\n\n            containerStyle.top = top + \"px\";\n            containerStyle.bottom = \"\";\n            containerStyle.left = left + \"px\";\n            containerStyle.maxHeight = maxHeight + \"px\";\n        }\n\n        // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)\n        calc();\n        calc();\n\n        if (settings.customize && inputRect) {\n            settings.customize(input, inputRect, container, maxHeight);\n        }\n    }\n\n    /**\n     * Redraw the autocomplete div element with suggestions\n     */\n    function update(): void {\n\n        // delete all children from autocomplete DOM container\n        while (container.firstChild) {\n            container.removeChild(container.firstChild);\n        }\n\n        input.setAttribute(\"aria-activedescendant\", \"\");\n\n        // function for rendering autocomplete suggestions\n        let render = function (item: T, _: string, __: number): HTMLDivElement | undefined {\n            const itemElement = doc.createElement(\"div\");\n            itemElement.textContent = item.label || \"\";\n            return itemElement;\n        };\n        if (settings.render) {\n            render = settings.render;\n        }\n\n        // function to render autocomplete groups\n        let renderGroup = function (groupName: string, _: string): HTMLDivElement | undefined {\n            const groupDiv = doc.createElement(\"div\");\n            groupDiv.textContent = groupName;\n            return groupDiv;\n        };\n        if (settings.renderGroup) {\n            renderGroup = settings.renderGroup;\n        }\n\n        const fragment = doc.createDocumentFragment();\n        let prevGroup = \"#9?$\";\n\n        items.forEach(function (item: T, index: number): void {\n            if (item.group && item.group !== prevGroup) {\n                prevGroup = item.group;\n                const groupDiv = renderGroup(item.group, inputValue);\n                if (groupDiv) {\n                    groupDiv.className += \" group\";\n                    fragment.appendChild(groupDiv);\n                }\n            }\n            const div = render(item, inputValue, index);\n            if (div) {\n                div.id = `${container.id}_${index}`;\n                div.setAttribute(\"role\", \"option\");\n                div.addEventListener(\"click\", function (ev: MouseEvent): void {\n                    settings.onSelect(item, input);\n                    clear();\n                    ev.preventDefault();\n                    ev.stopPropagation();\n                });\n                if (item === selected) {\n                    div.className += \" selected\";\n                    div.setAttribute(\"aria-selected\", \"true\");\n                    input.setAttribute(\"aria-activedescendant\", div.id);\n                }\n                fragment.appendChild(div);\n            }\n        });\n        container.appendChild(fragment);\n        if (items.length < 1) {\n            if (settings.emptyMsg) {\n                const empty = doc.createElement(\"div\");\n                empty.id = `${container.id}_${uid()}`;\n                empty.className = \"empty\";\n                empty.textContent = settings.emptyMsg;\n                container.appendChild(empty);\n                input.setAttribute(\"aria-activedescendant\", empty.id);\n            } else {\n                clear();\n                return;\n            }\n        }\n\n        attach();\n        updatePosition();\n\n        updateScroll();\n    }\n\n    function updateIfDisplayed(): void {\n        if (containerDisplayed()) {\n            update();\n        }\n    }\n\n    function resizeEventHandler(): void {\n        updateIfDisplayed();\n    }\n\n    function scrollEventHandler(e: Event): void {\n        if (e.target !== container) {\n            updateIfDisplayed();\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    function inputEventHandler(): void {\n        startFetch(EventTrigger.Keyboard);\n    }\n\n    /**\n     * Automatically move scroll bar if selected item is not visible\n     */\n    function updateScroll(): void {\n        const elements = container.getElementsByClassName(\"selected\");\n        if (elements.length > 0) {\n            let element = elements[0] as HTMLDivElement;\n\n            // make group visible\n            const previous = element.previousElementSibling as HTMLDivElement;\n            if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\n                element = previous;\n            }\n\n            if (element.offsetTop < container.scrollTop) {\n                container.scrollTop = element.offsetTop;\n            } else {\n                const selectBottom = element.offsetTop + element.offsetHeight;\n                const containerBottom = container.scrollTop + container.offsetHeight;\n                if (selectBottom > containerBottom) {\n                    container.scrollTop += selectBottom - containerBottom;\n                }\n            }\n        }\n    }\n\n    /**\n     * Select the previous item in suggestions\n     */\n    function selectPrev(): void {\n        if (items.length < 1) {\n            selected = undefined;\n        } else {\n            if (selected === items[0]) {\n                selected = items[items.length - 1];\n            } else {\n                for (let i = items.length - 1; i > 0; i--) {\n                    if (selected === items[i] || i === 1) {\n                        selected = items[i - 1];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Select the next item in suggestions\n     */\n    function selectNext(): void {\n        if (items.length < 1) {\n            selected = undefined;\n        }\n        if (!selected || selected === items[items.length - 1]) {\n            selected = items[0];\n            return;\n        }\n        for (let i = 0; i < (items.length - 1); i++) {\n            if (selected === items[i]) {\n                selected = items[i + 1];\n                break;\n            }\n        }\n    }\n\n    function keydownEventHandler(ev: KeyboardEvent): void {\n        const keyCode = ev.which || ev.keyCode || 0;\n\n        if (keyCode === Keys.Up || keyCode === Keys.Down || keyCode === Keys.Esc) {\n            const containerIsDisplayed = containerDisplayed();\n\n            if (keyCode === Keys.Esc) {\n                clear();\n            } else {\n                if (!containerIsDisplayed || items.length < 1) {\n                    return;\n                }\n                keyCode === Keys.Up\n                    ? selectPrev()\n                    : selectNext();\n                update();\n            }\n\n            ev.preventDefault();\n            if (containerIsDisplayed) {\n                ev.stopPropagation();\n            }\n\n            return;\n        }\n\n        if (keyCode === Keys.Enter) {\n            if (selected) {\n                settings.onSelect(selected, input);\n                clear();\n            }\n\n            if (preventSubmit) {\n                ev.preventDefault();\n            }\n        }\n    }\n\n    function focusEventHandler(): void {\n        if (showOnFocus) {\n            startFetch(EventTrigger.Focus);\n        }\n    }\n\n    function startFetch(trigger: EventTrigger) {\n        // If multiple keys were pressed, before we get an update from server,\n        // this may cause redrawing autocomplete multiple times after the last key was pressed.\n        // To avoid this, the number of times keyboard was pressed will be saved and checked before redraw.\n        const savedKeypressCounter = ++keypressCounter;\n\n        const inputText = input.value;\n        const cursorPos = input.selectionStart || 0;\n\n        if (inputText.length >= minLen || trigger === EventTrigger.Focus) {\n            clearDebounceTimer();\n            debounceTimer = window.setTimeout(function (): void {\n                settings.fetch(inputText, function (elements: T[] | false): void {\n                    if (keypressCounter === savedKeypressCounter && elements) {\n                        items = elements;\n                        inputValue = inputText;\n                        selected = (items.length < 1 || disableAutoSelect) ? undefined : items[0];\n                        update();\n                    }\n                }, trigger, cursorPos);\n            }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);\n        } else {\n            clear();\n        }\n    }\n\n    function blurEventHandler(): void {\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n        setTimeout(() => {\n            if (doc.activeElement !== input) {\n                clear();\n            }\n        }, 200);\n    }\n\n    /**\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\n     */\n    container.addEventListener(\"mousedown\", function (evt: Event) {\n        evt.stopPropagation();\n        evt.preventDefault();\n    });\n\n    /**\n     * Fixes #30: autocomplete closes when scrollbar is clicked in IE\n     * See: https://stackoverflow.com/a/9210267/13172349\n     */\n    container.addEventListener(\"focus\", () => input.focus());\n\n    /**\n     * This function will remove DOM elements and clear event handlers\n     */\n    function destroy(): void {\n        input.removeEventListener(\"focus\", focusEventHandler);\n        input.removeEventListener(\"keydown\", keydownEventHandler as EventListenerOrEventListenerObject);\n        input.removeEventListener(\"input\", inputEventHandler as EventListenerOrEventListenerObject);\n        input.removeEventListener(\"blur\", blurEventHandler);\n        window.removeEventListener(\"resize\", resizeEventHandler);\n        doc.removeEventListener(\"scroll\", scrollEventHandler, true);\n        input.removeAttribute(\"role\");\n        input.removeAttribute(\"aria-expanded\");\n        input.removeAttribute(\"aria-autocomplete\");\n        input.removeAttribute(\"aria-controls\");\n        input.removeAttribute(\"aria-activedescendant\");\n        input.removeAttribute(\"aria-owns\");\n        input.removeAttribute(\"aria-haspopup\");\n        clearDebounceTimer();\n        clear();\n    }\n\n    // setup event handlers\n    input.addEventListener(\"keydown\", keydownEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener(\"input\", inputEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener(\"blur\", blurEventHandler);\n    input.addEventListener(\"focus\", focusEventHandler);\n    window.addEventListener(\"resize\", resizeEventHandler);\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\n\n    return {\n        destroy\n    };\n}\n"],"names":["settings","doc","document","container","createElement","id","uid","selected","debounceTimer","containerStyle","style","debounceWaitMs","preventSubmit","disableAutoSelect","items","inputValue","minLen","showOnFocus","keypressCounter","undefined","minLength","input","Error","Date","now","toString","Math","random","substring","clearDebounceTimer","window","clearTimeout","containerDisplayed","parentNode","clear","parent","setAttribute","removeChild","update","firstChild","render","item","_","__","itemElement","textContent","label","renderGroup","groupName","groupDiv","fragment","createDocumentFragment","prevGroup","forEach","index","group","className","appendChild","div","addEventListener","ev","onSelect","preventDefault","stopPropagation","length","emptyMsg","empty","body","height","width","offsetWidth","inputRect","maxHeight","calc","customize","docEl","documentElement","clientTop","clientLeft","scrollTop","pageYOffset","scrollLeft","pageXOffset","top","getBoundingClientRect","offsetHeight","left","innerHeight","bottom","updatePosition","elements","getElementsByClassName","element","previous","previousElementSibling","indexOf","offsetTop","selectBottom","containerBottom","updateScroll","updateIfDisplayed","resizeEventHandler","scrollEventHandler","e","target","inputEventHandler","startFetch","keydownEventHandler","keyCode","which","containerIsDisplayed","i","selectPrev","selectNext","focusEventHandler","trigger","savedKeypressCounter","inputText","value","cursorPos","selectionStart","setTimeout","fetch","blurEventHandler","activeElement","position","evt","focus","destroy","removeEventListener","removeAttribute"],"mappings":"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"}