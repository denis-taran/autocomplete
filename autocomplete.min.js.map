{"version":3,"file":"autocomplete.min.js","sources":["autocomplete.ts"],"sourcesContent":["/**\n * Copyright (c) 2016 Denys Krasnoshchok\n * \n * Homepage: https://smartscheduling.com/en/documentation/autocomplete\n * Source: https://github.com/kraaden/autocomplete\n * \n * MIT License\n */\n\nexport const enum EventTrigger {\n    Keyboard = 0,\n    Focus = 1,\n    Mouse = 2,\n    /**\n     * Fetch is triggered manually by calling `fetch` function returned in `AutocompleteResult`\n     */\n    Manual = 3\n}\n\n/**\n * Enum for controlling form submission when `ENTER` key is pressed in the autocomplete input field.\n */\nexport const enum PreventSubmit {\n    Never = 0,\n    Always = 1,\n    /**\n     * Form submission is prevented only when an item is selected from the autocomplete list.\n     */\n    OnSelect = 2\n}\n\nexport interface AutocompleteItem {\n    label?: string;\n    group?: string;\n}\n\nexport interface AutocompleteEvent<T extends Event> {\n    /**\n     * Native event object passed by browser to the event handler\n     */\n    event: T;\n\n    /**\n     * Fetch data and display autocomplete\n     */\n    fetch: () => void;\n}\n\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\n    /**\n     * Autocomplete will be attached to this element.\n     */\n    input: HTMLInputElement | HTMLTextAreaElement;\n\n    /**\n     * Provide your own container for the widget.\n     * If not specified, a new DIV element will be created.\n     */\n    container?: HTMLDivElement;\n\n    /**\n     * This method allows you to override the default rendering function for items.\n     * It must return a DIV element or undefined to skip rendering.\n     */\n    render?: (item: T, currentValue: string, index: number) => HTMLDivElement | undefined;\n\n    /**\n     * This method allows you to override the default rendering function for item groups.\n     * It must return a DIV element or undefined to skip rendering.\n     */\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\n\n    /**\n     * If specified, the autocomplete DOM element will have this class assigned to it.\n     */\n    className?: string;\n\n    /**\n     * Specify the minimum text length required to show autocomplete.\n     */\n    minLength?: number;\n\n    /**\n     * The message that will be showed when there are no suggestions that match the entered value.\n     */\n    emptyMsg?: string;\n\n    /**\n     * This method will be called when user choose an item in autocomplete. The selected item will be passed as the first parameter.\n     */\n    onSelect: (item: T, input: HTMLInputElement | HTMLTextAreaElement) => void;\n\n    /**\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\n     */\n    showOnFocus?: boolean;\n\n    /**\n     * This method will be called to prepare suggestions and then pass them to autocomplete.\n     * @param {string} text - text in the input field\n     * @param {(items: T[] | false) => void} update - a callback function that must be called after suggestions are prepared\n     * @param {EventTrigger} trigger - type of the event that triggered the fetch\n     * @param {number} cursorPos - position of the cursor in the input field\n     */\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger, cursorPos: number) => void;\n\n    /**\n     * Enforces that the fetch function will only be called once within the specified time frame (in milliseconds) and\n     * delays execution. This prevents flooding your server with AJAX requests.\n     */\n    debounceWaitMs?: number;\n\n    /**\n     * Callback for additional autocomplete customization\n     * @param {HTMLInputElement | HTMLTextAreaElement} input - input box associated with autocomplete\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\n     * @param {HTMLDivElement} container - container with suggestions\n     * @param {number} maxHeight - max height that can be used by autocomplete\n     */\n    customize?: (input: HTMLInputElement | HTMLTextAreaElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\n\n    /**\n     * Controls form submission when the ENTER key is pressed in a input field.\n     */\n    preventSubmit?: PreventSubmit;\n\n    /**\n     * Prevents the first item in the list from being selected automatically. This option allows you\n     * to submit a custom text by pressing ENTER even when autocomplete is displayed.\n     */\n    disableAutoSelect?: boolean;\n\n    /**\n     * Provide your keyup event handler to display autocomplete when a key is pressed that doesn't modify the content. You can also perform some additional actions.\n     */\n    keyup?: (e: AutocompleteEvent<KeyboardEvent>) => void;\n\n    /**\n     * Allows to display autocomplete on mouse clicks or perform some additional actions.\n     */\n    click?: (e: AutocompleteEvent<MouseEvent>) => void;\n}\n\nexport interface AutocompleteResult {\n    /**\n     * Remove event handlers, DOM elements and ARIA/accessibility attributes created by the widget.\n     */\n    destroy: () => void;\n\n    /**\n     * This function allows to manually start data fetching and display autocomplete. Note that\n     * it does not automatically place focus on the input field, so you may need to do so manually\n     * in certain situations.\n     */\n    fetch: () => void;\n}\n\n// Constants for blur event timeout in milliseconds\nconst IOS_BLUR_FIX_TIMEOUT = 800;\nconst DEFAULT_BLUR_TIMEOUT = 200;\n\nexport default function autocomplete<T extends AutocompleteItem>(settings: AutocompleteSettings<T>): AutocompleteResult {\n\n    // just an alias to minimize JS file size\n    const doc = document;\n\n    const container: HTMLDivElement = settings.container || doc.createElement('div');\n    const preventSubmit: PreventSubmit = settings.preventSubmit || PreventSubmit.Never;\n    const isIos = isMobileSafari();\n\n    container.id = container.id || 'autocomplete-' + uid();\n    const containerStyle = container.style;\n    const debounceWaitMs = settings.debounceWaitMs || 0;\n    const disableAutoSelect = settings.disableAutoSelect || false;\n    const customContainerParent = container.parentElement;\n\n    let items: T[] = [];\n    let inputValue = '';\n    let minLen = 2;\n    const showOnFocus = settings.showOnFocus;\n    let selected: T | undefined;\n    let fetchCounter = 0;\n    let debounceTimer: number | undefined;\n    let destroyed = false;\n\n    // Fixes #104: autocomplete selection is broken on Firefox for Android\n    let suppressAutocomplete = false;\n\n    let lastViewportHeight = window.visualViewport?.height || 0;\n    let blurTimeoutId: ReturnType<typeof setTimeout> | null = null;\n\n    if (settings.minLength !== undefined) {\n        minLen = settings.minLength;\n    }\n\n    if (!settings.input) {\n        throw new Error('input undefined');\n    }\n\n    const input: HTMLInputElement | HTMLTextAreaElement = settings.input;\n\n    container.className = 'autocomplete ' + (settings.className || '');\n    container.setAttribute('role', 'listbox');\n\n    input.setAttribute('role', 'combobox');\n    input.setAttribute('aria-expanded', 'false');\n    input.setAttribute('aria-autocomplete', 'list');\n    input.setAttribute('aria-controls', container.id);\n    input.setAttribute('aria-owns', container.id);\n    input.setAttribute('aria-activedescendant', '');\n    input.setAttribute('aria-haspopup', 'listbox');\n\n    // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\n    containerStyle.position = 'absolute';\n\n    /**\n     * Generate a very complex textual ID that greatly reduces the chance of a collision with another ID or text.\n     */\n    function uid(): string {\n        return Date.now().toString(36) + Math.random().toString(36).substring(2);\n    }\n\n    /**\n     * Detach the container from DOM\n     */\n    function detach() {\n        const parent = container.parentNode;\n        if (parent) {\n            parent.removeChild(container);\n        }\n    }\n\n    /**\n     * Clear debouncing timer if assigned\n     */\n    function clearDebounceTimer() {\n        if (debounceTimer) {\n            window.clearTimeout(debounceTimer);\n        }\n    }\n\n    /**\n     * Attach the container to DOM\n     */\n    function attach() {\n        if (!container.parentNode) {\n            (customContainerParent || doc.body).appendChild(container);\n        }\n    }\n\n    /**\n     * Check if container for autocomplete is displayed\n     */\n    function containerDisplayed(): boolean {\n        return !!container.parentNode;\n    }\n\n    /**\n     * Detect if the user is using a mobile IOS device\n     */\n    function isMobileSafari() {\n        var platforms = ['iPhone', 'iPad', 'iPod'];\n        return platforms.indexOf(navigator.platform || '') !== -1;\n    }\n\n    /**\n     * Clear autocomplete state and hide container\n     */\n    function clear() {\n        // prevent the update call if there are pending AJAX requests\n        fetchCounter++;\n\n        items = [];\n        inputValue = '';\n        selected = undefined;\n        input.setAttribute('aria-activedescendant', '');\n        input.setAttribute('aria-expanded', 'false');\n        detach();\n    }\n\n    /**\n     * Update autocomplete position\n     */\n    function updatePosition() {\n        if (!containerDisplayed()) {\n            return;\n        }\n\n        input.setAttribute('aria-expanded', 'true');\n\n        containerStyle.height = 'auto';\n        containerStyle.width = input.offsetWidth + 'px';\n\n        let maxHeight = 0;\n        let inputRect: DOMRect | undefined;\n\n        function calc() {\n            const docEl = doc.documentElement as HTMLElement;\n            const clientTop = docEl.clientTop || doc.body.clientTop || 0;\n            const clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;\n            const scrollTop = window.pageYOffset || docEl.scrollTop;\n            const scrollLeft = window.pageXOffset || docEl.scrollLeft;\n\n            inputRect = input.getBoundingClientRect();\n\n            const top = inputRect.top + input.offsetHeight + scrollTop - clientTop;\n            const left = inputRect.left + scrollLeft - clientLeft;\n\n            containerStyle.top = top + 'px';\n            containerStyle.left = left + 'px';\n\n            maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\n\n            if (maxHeight < 0) {\n                maxHeight = 0;\n            }\n\n            containerStyle.top = top + 'px';\n            containerStyle.bottom = '';\n            containerStyle.left = left + 'px';\n            containerStyle.maxHeight = maxHeight + 'px';\n        }\n\n        // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)\n        calc();\n        calc();\n\n        if (settings.customize && inputRect) {\n            settings.customize(input, inputRect, container, maxHeight);\n        }\n    }\n\n    /**\n     * Redraw the autocomplete div element with suggestions\n     */\n    function update() {\n\n        container.innerHTML = '';\n        input.setAttribute('aria-activedescendant', '');\n\n        // function for rendering autocomplete suggestions\n        let render = function (item: T, _: string, __: number): HTMLDivElement | undefined {\n            const itemElement = doc.createElement('div');\n            itemElement.textContent = item.label || '';\n            return itemElement;\n        };\n        if (settings.render) {\n            render = settings.render;\n        }\n\n        // function to render autocomplete groups\n        let renderGroup = function (groupName: string, _: string): HTMLDivElement | undefined {\n            const groupDiv = doc.createElement('div');\n            groupDiv.textContent = groupName;\n            return groupDiv;\n        };\n        if (settings.renderGroup) {\n            renderGroup = settings.renderGroup;\n        }\n\n        const fragment = doc.createDocumentFragment();\n        let prevGroup = uid();\n\n        items.forEach(function (item: T, index: number): void {\n            if (item.group && item.group !== prevGroup) {\n                prevGroup = item.group;\n                const groupDiv = renderGroup(item.group, inputValue);\n                if (groupDiv) {\n                    groupDiv.className += ' group';\n                    fragment.appendChild(groupDiv);\n                }\n            }\n            const div = render(item, inputValue, index);\n            if (div) {\n                div.id = `${container.id}_${index}`;\n                div.setAttribute('role', 'option');\n                div.addEventListener('click', function (ev: MouseEvent): void {\n                    suppressAutocomplete = true;\n                    try {\n                        settings.onSelect(item, input);\n                    } finally {\n                        suppressAutocomplete = false;\n                    }\n                    clear();\n                    ev.preventDefault();\n                    ev.stopPropagation();\n                });\n                if (item === selected) {\n                    div.className += ' selected';\n                    div.setAttribute('aria-selected', 'true');\n                    input.setAttribute('aria-activedescendant', div.id);\n                }\n                fragment.appendChild(div);\n            }\n        });\n        container.appendChild(fragment);\n        if (items.length < 1) {\n            if (settings.emptyMsg) {\n                const empty = doc.createElement('div');\n                empty.id = `${container.id}_${uid()}`;\n                empty.className = 'empty';\n                empty.textContent = settings.emptyMsg;\n                container.appendChild(empty);\n                input.setAttribute('aria-activedescendant', empty.id);\n            } else {\n                clear();\n                return;\n            }\n        }\n\n        attach();\n        updatePosition();\n\n        updateScroll();\n    }\n\n    function updateIfDisplayed() {\n        if (containerDisplayed()) {\n            update();\n        }\n    }\n\n    /**\n     * Prevents execution of the blur callback (which removes autocomplete suggestions) when the virtual keyboard closes on iOS\n     * Compares the current and last viewport heights, if the current height is greater and \n     * a blur timeout is set, it cancels the timeout\n     */\n    function iosBlurFix() {\n        if (!isIos) return;\n\n        if ((window.visualViewport?.height || 0) > lastViewportHeight && blurTimeoutId) {\n            clearTimeout(blurTimeoutId);\n            blurTimeoutId = null;\n        }\n\n        lastViewportHeight = window.visualViewport?.height || 0;\n    }\n\n    function resizeEventHandler() {\n        updateIfDisplayed();\n    }\n\n    function scrollEventHandler(e: Event) {\n        if (e.target !== container) {\n            updateIfDisplayed();\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    function inputEventHandler() {\n        if (!suppressAutocomplete) {\n            fetch(EventTrigger.Keyboard);\n        }\n    }\n\n    /**\n     * Automatically move scroll bar if selected item is not visible\n     */\n    function updateScroll() {\n        const elements = container.getElementsByClassName('selected');\n        if (elements.length > 0) {\n            let element = elements[0] as HTMLDivElement;\n\n            // make group visible\n            const previous = element.previousElementSibling as HTMLDivElement;\n            if (previous && previous.className.indexOf('group') !== -1 && !previous.previousElementSibling) {\n                element = previous;\n            }\n\n            if (element.offsetTop < container.scrollTop) {\n                container.scrollTop = element.offsetTop;\n            } else {\n                const selectBottom = element.offsetTop + element.offsetHeight;\n                const containerBottom = container.scrollTop + container.offsetHeight;\n                if (selectBottom > containerBottom) {\n                    container.scrollTop += selectBottom - containerBottom;\n                }\n            }\n        }\n    }\n\n    function selectPreviousSuggestion() {\n        const index = items.indexOf(selected!);\n\n        selected = index === -1\n            ? undefined\n            : items[(index + items.length - 1) % items.length];\n\n        updateSelectedSuggestion(index);\n    }\n\n    function selectNextSuggestion() {\n        const index = items.indexOf(selected!);\n\n        selected = items.length < 1\n            ? undefined\n            : index === -1\n                ? items[0]\n                : items[(index + 1) % items.length];\n\n        updateSelectedSuggestion(index);\n    }\n\n    function updateSelectedSuggestion(index: number) {\n        if (items.length > 0) {\n            unselectSuggestion(index);\n            selectSuggestion(items.indexOf(selected!));\n            updateScroll();\n        }\n    }\n\n    function selectSuggestion(index: number) {\n        var element = doc.getElementById(container.id + \"_\" + index);\n        if (element) {\n            element.classList.add('selected');\n            element.setAttribute('aria-selected', 'true');\n            input.setAttribute('aria-activedescendant', element.id);\n        }\n    }\n\n    function unselectSuggestion(index: number) {\n        var element = doc.getElementById(container.id + \"_\" + index);\n        if (element) {\n            element.classList.remove('selected');\n            element.removeAttribute('aria-selected');\n            input.removeAttribute('aria-activedescendant');\n        }\n    }\n\n    function handleArrowAndEscapeKeys(ev: KeyboardEvent, key: 'ArrowUp' | 'ArrowDown' | 'Escape') {\n        const containerIsDisplayed = containerDisplayed();\n\n        if (key === 'Escape') {\n            clear();\n        } else {\n            if (!containerIsDisplayed || items.length < 1) {\n                return;\n            }\n            key === 'ArrowUp'\n                ? selectPreviousSuggestion()\n                : selectNextSuggestion();\n        }\n\n        ev.preventDefault();\n\n        if (containerIsDisplayed) {\n            ev.stopPropagation();\n        }\n    }\n\n    function handleEnterKey(ev: KeyboardEvent) {\n        if (selected) {\n            if (preventSubmit === PreventSubmit.OnSelect) {\n                ev.preventDefault();\n            }\n            suppressAutocomplete = true;\n            try {\n                settings.onSelect(selected, input);\n            } finally {\n                suppressAutocomplete = false;\n            }\n            clear();\n        }\n\n        if (preventSubmit === PreventSubmit.Always) {\n            ev.preventDefault();\n        }\n    }\n\n    function keydownEventHandler(ev: KeyboardEvent) {\n        const key = ev.key;\n\n        switch (key) {\n            case 'ArrowUp':\n            case 'ArrowDown':\n            case 'Escape':\n                handleArrowAndEscapeKeys(ev, key);\n                break;\n            case 'Enter':\n                handleEnterKey(ev);\n                break;\n            default:\n                break;\n        }\n    }\n\n    function focusEventHandler() {\n        if (showOnFocus) {\n            fetch(EventTrigger.Focus);\n        }\n    }\n\n    function fetch(trigger: EventTrigger) {\n        if (input.value.length >= minLen || trigger === EventTrigger.Focus) {\n            clearDebounceTimer();\n            debounceTimer = window.setTimeout(\n                () => startFetch(input.value, trigger, input.selectionStart || 0),\n                trigger === EventTrigger.Keyboard || trigger === EventTrigger.Mouse ? debounceWaitMs : 0);\n        } else {\n            clear();\n        }\n    }\n\n    function startFetch(inputText: string, trigger: EventTrigger, cursorPos: number) {\n        if (destroyed) return;\n        const savedFetchCounter = ++fetchCounter;\n        settings.fetch(inputText, function (elements: T[] | false): void {\n            if (fetchCounter === savedFetchCounter && elements) {\n                items = elements;\n                inputValue = inputText;\n                selected = (items.length < 1 || disableAutoSelect) ? undefined : items[0];\n                update();\n            }\n        }, trigger, cursorPos);\n    }\n\n    function keyupEventHandler(e: KeyboardEvent) {\n        if (settings.keyup) {\n            settings.keyup({\n                event: e,\n                fetch: () => fetch(EventTrigger.Keyboard)\n            });\n            return;\n        }\n\n        if (!containerDisplayed() && e.key === 'ArrowDown') {\n            fetch(EventTrigger.Keyboard);\n        }\n    }\n\n    function clickEventHandler(e: MouseEvent) {\n        settings.click && settings.click({\n            event: e,\n            fetch: () => fetch(EventTrigger.Mouse)\n        });\n    }\n\n    function blurEventHandler(e: FocusEvent) {\n        const delay = isIos\n            ? e.relatedTarget === doc.body || e.relatedTarget === null\n                ? IOS_BLUR_FIX_TIMEOUT\n                : DEFAULT_BLUR_TIMEOUT\n            : DEFAULT_BLUR_TIMEOUT;\n\n        // when an item is selected by mouse click, the blur event will be initiated before the click event and remove DOM elements,\n        // so that the click event will never be triggered. In order to avoid this issue, DOM removal should be delayed.\n        blurTimeoutId = setTimeout(() => {\n            if (doc.activeElement !== input) {\n                clear();\n            }\n            blurTimeoutId = null;\n        }, delay);\n    }\n\n    function manualFetch() {\n        startFetch(input.value, EventTrigger.Manual, input.selectionStart || 0);\n    }\n\n    /**\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\n     */\n    container.addEventListener('mousedown', function (evt: Event) {\n        evt.stopPropagation();\n        evt.preventDefault();\n    });\n\n    /**\n     * Fixes #30: autocomplete closes when scrollbar is clicked in IE\n     * See: https://stackoverflow.com/a/9210267/13172349\n     */\n    container.addEventListener('focus', () => input.focus());\n\n    /**\n     * This function will remove DOM elements and clear event handlers\n     */\n    function destroy() {\n        input.removeEventListener('focus', focusEventHandler);\n        input.removeEventListener('keyup', keyupEventHandler as EventListenerOrEventListenerObject)\n        input.removeEventListener('click', clickEventHandler as EventListenerOrEventListenerObject)\n        input.removeEventListener('keydown', keydownEventHandler as EventListenerOrEventListenerObject);\n        input.removeEventListener('input', inputEventHandler as EventListenerOrEventListenerObject);\n        input.removeEventListener('blur', blurEventHandler as EventListenerOrEventListenerObject);\n        window.removeEventListener('resize', resizeEventHandler);\n        window.visualViewport?.removeEventListener('resize', iosBlurFix)\n        doc.removeEventListener('scroll', scrollEventHandler, true);\n        input.removeAttribute('role');\n        input.removeAttribute('aria-expanded');\n        input.removeAttribute('aria-autocomplete');\n        input.removeAttribute('aria-controls');\n        input.removeAttribute('aria-activedescendant');\n        input.removeAttribute('aria-owns');\n        input.removeAttribute('aria-haspopup');\n        clearDebounceTimer();\n        clear();\n        destroyed = true;\n    }\n\n    // setup event handlers\n    input.addEventListener('keyup', keyupEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener('click', clickEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener('keydown', keydownEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener('input', inputEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener('blur', blurEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener('focus', focusEventHandler);\n    window.addEventListener('resize', resizeEventHandler);\n    window.visualViewport?.addEventListener('resize', iosBlurFix)\n    doc.addEventListener('scroll', scrollEventHandler, true);\n\n    return {\n        destroy,\n        fetch: manualFetch\n    };\n}\n"],"names":["settings","doc","document","container","createElement","preventSubmit","isIos","indexOf","navigator","platform","id","uid","selected","debounceTimer","containerStyle","style","debounceWaitMs","disableAutoSelect","customContainerParent","parentElement","items","inputValue","minLen","showOnFocus","fetchCounter","destroyed","suppressAutocomplete","lastViewportHeight","window","visualViewport","height","blurTimeoutId","undefined","minLength","input","Error","Date","now","toString","Math","random","substring","clearDebounceTimer","clearTimeout","containerDisplayed","parentNode","clear","parent","setAttribute","removeChild","update","innerHTML","render","item","_","__","itemElement","textContent","label","renderGroup","groupName","groupDiv","fragment","createDocumentFragment","prevGroup","forEach","index","group","className","appendChild","div","addEventListener","ev","onSelect","preventDefault","stopPropagation","length","emptyMsg","empty","body","width","offsetWidth","inputRect","maxHeight","calc","customize","docEl","documentElement","clientTop","clientLeft","scrollTop","pageYOffset","scrollLeft","pageXOffset","top","getBoundingClientRect","offsetHeight","left","innerHeight","bottom","updatePosition","updateScroll","updateIfDisplayed","iosBlurFix","resizeEventHandler","scrollEventHandler","e","target","inputEventHandler","fetch","elements","getElementsByClassName","element","previous","previousElementSibling","offsetTop","selectBottom","containerBottom","updateSelectedSuggestion","getElementById","classList","remove","removeAttribute","unselectSuggestion","add","selectSuggestion","handleArrowAndEscapeKeys","key","containerIsDisplayed","selectNextSuggestion","keydownEventHandler","handleEnterKey","focusEventHandler","trigger","value","setTimeout","startFetch","selectionStart","inputText","cursorPos","savedFetchCounter","keyupEventHandler","keyup","event","clickEventHandler","click","blurEventHandler","delay","relatedTarget","activeElement","position","evt","focus","destroy","removeEventListener"],"mappings":"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"}