{"version":3,"file":"autocomplete.min.js","sources":["autocomplete.ts"],"sourcesContent":[" /*\r\n  * https://github.com/kraaden/autocomplete\r\n  * Copyright (c) 2016 Denys Krasnoshchok\r\n  * MIT License\r\n  */\r\n\r\n export const enum EventTrigger {\r\n    Keyboard = 0,\r\n    Focus = 1\r\n}\r\n\r\nexport interface AutocompleteItem {\r\n    label?: string;\r\n    group?: string;\r\n}\r\n\r\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\r\n    /**\r\n     * Autocomplete will be attached to this element.\r\n     */\r\n    input: HTMLInputElement | HTMLTextAreaElement;\r\n\r\n    /**\r\n     * Provide your own container for the widget.\r\n     * If not specified, a new DIV element will be created.\r\n     */\r\n    container?: HTMLDivElement;\r\n\r\n    /**\r\n     * This method allows you to override the default rendering function for items.\r\n     * It must return a DIV element or undefined to skip rendering.\r\n     */\r\n    render?: (item: T, currentValue: string) => HTMLDivElement | undefined;\r\n\r\n    /**\r\n     * This method allows you to override the default rendering function for item groups.\r\n     * It must return a DIV element or undefined to skip rendering.\r\n     */\r\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\r\n\r\n    /**\r\n     * If specified, the autocomplete DOM element will have this class assigned to it.\r\n     */\r\n    className?: string;\r\n\r\n    /**\r\n     * Specify the minimum text length required to show autocomplete.\r\n     */\r\n    minLength?: number;\r\n\r\n    /**\r\n     * The message that will be showed when there are no suggestions that match the entered value.\r\n     */\r\n    emptyMsg?: string;\r\n\r\n    /**\r\n     * This method will be called when user choose an item in autocomplete. The selected item will be passed as the first parameter.\r\n     */\r\n    onSelect: (item: T, input: HTMLInputElement | HTMLTextAreaElement) => void;\r\n\r\n    /**\r\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\r\n     */\r\n    showOnFocus?: boolean;\r\n\r\n    /**\r\n     * This method will be called to prepare suggestions and then pass them to autocomplete.\r\n     * @param {string} text - text in the input field\r\n     * @param {(items: T[] | false) => void} update - a callback function that must be called after suggestions are prepared\r\n     * @param {EventTrigger} trigger - type of the event that triggered the fetch\r\n     * @param {number} cursorPos - position of the cursor in the input field\r\n     */\r\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger, cursorPos: number) => void;\r\n\r\n    /**\r\n     * Enforces that the fetch function will only be called once within the specified time frame (in milliseconds) and\r\n     * delays execution. This prevents flooding your server with AJAX requests.\r\n     */\r\n    debounceWaitMs?: number;\r\n\r\n    /**\r\n     * Callback for additional autocomplete customization\r\n     * @param {HTMLInputElement | HTMLTextAreaElement} input - input box associated with autocomplete\r\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\r\n     * @param {HTMLDivElement} container - container with suggestions\r\n     * @param {number} maxHeight - max height that can be used by autocomplete\r\n     */\r\n    customize?: (input: HTMLInputElement | HTMLTextAreaElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\r\n\r\n    /**\r\n     * Prevents automatic form submit when ENTER is pressed\r\n     */\r\n    preventSubmit?: boolean;\r\n    \r\n    /**\r\n     * Prevents the first item in the list from being selected automatically. This option allows you\r\n     * to submit a custom text by pressing ENTER even when autocomplete is displayed.\r\n     */\r\n    disableAutoSelect?: boolean;\r\n\r\n    /**\r\n     * Keys that will be ignored and not trigger the fetch callback.\r\n     */\r\n    keysToIgnore?: Keys[];\r\n}\r\n\r\nexport interface AutocompleteResult {\r\n    destroy: () => void;\r\n}\r\n\r\nexport const enum Keys {\r\n    Enter = 13,\r\n    Esc = 27,\r\n    Up = 38,\r\n    Down = 40,\r\n    Left = 37,\r\n    Right = 39,\r\n    Shift = 16,\r\n    Ctrl = 17,\r\n    Alt = 18,\r\n    CapsLock = 20,\r\n    WindowsKey = 91,\r\n    Tab = 9,\r\n    F1 = 112,\r\n    F12 = 123\r\n}\r\n\r\nexport default function autocomplete<T extends AutocompleteItem>(settings: AutocompleteSettings<T>): AutocompleteResult {\r\n\r\n    // just an alias to minimize JS file size\r\n    const doc = document;\r\n\r\n    const container: HTMLDivElement = settings.container || doc.createElement(\"div\");\r\n    let containerId = container.id;\r\n    if(!containerId || !containerId.length) {\r\n        let index = 0;\r\n        do {\r\n            containerId = \"autocomplete-\" + index++;\r\n        } while (doc.getElementById(containerId) != null && index < 100000);\r\n        container.id = containerId;\r\n    }\r\n    const containerStyle = container.style;\r\n    const userAgent = navigator.userAgent;\r\n    const mobileFirefox = ~userAgent.indexOf(\"Firefox\") && ~userAgent.indexOf(\"Mobile\");\r\n    const debounceWaitMs = settings.debounceWaitMs || 0;\r\n    const preventSubmit = settings.preventSubmit || false;\r\n    const disableAutoSelect = settings.disableAutoSelect || false;\r\n    \r\n    // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\r\n    const keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\r\n    \r\n    let items: T[] = [];\r\n    let inputValue = \"\";\r\n    let minLen = 2;\r\n    const showOnFocus = settings.showOnFocus;\r\n    let selected: T | undefined;\r\n    let keypressCounter = 0;\r\n    let debounceTimer : number | undefined;\r\n\r\n    if (settings.minLength !== undefined) {\r\n        minLen = settings.minLength;\r\n    }\r\n\r\n    if (!settings.input) {\r\n        throw new Error(\"input undefined\");\r\n    }\r\n\r\n    const input: HTMLInputElement | HTMLTextAreaElement = settings.input;\r\n\r\n    container.className = \"autocomplete \" + (settings.className || \"\");\r\n    input.setAttribute(\"aria-role\", \"combobox\");\r\n    input.setAttribute(\"aria-expanded\", \"false\");\r\n    input.setAttribute(\"aria-autocomplete\", \"list\");\r\n    input.setAttribute(\"aria-controls\", containerId);\r\n    input.setAttribute(\"aria-activedescendant\", \"\");\r\n    container.setAttribute(\"aria-role\", \"listbox\");\r\n\r\n    // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\r\n    containerStyle.position = \"absolute\";\r\n\r\n    /**\r\n     * Detach the container from DOM\r\n     */\r\n    function detach(): void {\r\n        const parent = container.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\r\n    function clearDebounceTimer(): void {\r\n        if (debounceTimer) {\r\n            window.clearTimeout(debounceTimer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the container to DOM\r\n     */\r\n    function attach(): void {\r\n        if (!container.parentNode) {\r\n            doc.body.appendChild(container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\r\n    function containerDisplayed(): boolean {\r\n        return !!container.parentNode;\r\n    }\r\n\r\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\r\n    function clear(): void {\r\n        // prevent the update call if there are pending AJAX requests\r\n        keypressCounter++;\r\n        \r\n        items = [];\r\n        inputValue = \"\";\r\n        selected = undefined;\r\n        input.setAttribute(\"aria-activedescendant\", \"\");\r\n        input.setAttribute(\"aria-expanded\", \"false\");\r\n        detach();\r\n    }\r\n\r\n    /**\r\n     * Update autocomplete position\r\n     */\r\n    function updatePosition(): void {\r\n        if (!containerDisplayed()) {\r\n            return;\r\n        }\r\n        \r\n        input.setAttribute(\"aria-expanded\", \"true\");\r\n\r\n        containerStyle.height = \"auto\";\r\n        containerStyle.width = input.offsetWidth + \"px\";\r\n\r\n        let maxHeight = 0;\r\n        let inputRect: ClientRect | DOMRect | undefined;\r\n\r\n        function calc() {\r\n            const docEl = doc.documentElement as HTMLElement;\r\n            const clientTop = docEl.clientTop || doc.body.clientTop || 0;\r\n            const clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;\r\n            const scrollTop = window.pageYOffset || docEl.scrollTop;\r\n            const scrollLeft = window.pageXOffset || docEl.scrollLeft;\r\n\r\n            inputRect = input.getBoundingClientRect();\r\n        \r\n            const top = inputRect.top + input.offsetHeight + scrollTop - clientTop;\r\n            const left = inputRect.left + scrollLeft - clientLeft;\r\n    \r\n            containerStyle.top = top + \"px\";\r\n            containerStyle.left = left + \"px\";\r\n    \r\n            maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\r\n    \r\n            if (maxHeight < 0) {\r\n                maxHeight = 0;\r\n            }\r\n    \r\n            containerStyle.top = top + \"px\";\r\n            containerStyle.bottom = \"\";\r\n            containerStyle.left = left + \"px\";\r\n            containerStyle.maxHeight = maxHeight + \"px\";\r\n        }\r\n\r\n        // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)\r\n        calc();\r\n        calc();\r\n\r\n        if (settings.customize && inputRect) {\r\n            settings.customize(input, inputRect, container, maxHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\r\n    function update(): void {\r\n        \r\n        // delete all children from autocomplete DOM container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n\r\n        // function for rendering autocomplete suggestions\r\n        let render = function(item: T, currentValue: string): HTMLDivElement | undefined {\r\n            const itemElement = doc.createElement(\"div\");\r\n            itemElement.textContent = item.label || \"\";\r\n            return itemElement;\r\n        };\r\n        if (settings.render) {\r\n            render = settings.render;\r\n        }\r\n\r\n        // function to render autocomplete groups\r\n        let renderGroup = function(groupName: string, currentValue: string): HTMLDivElement | undefined {\r\n            const groupDiv = doc.createElement(\"div\");\r\n            groupDiv.textContent = groupName;\r\n            return groupDiv;\r\n        };\r\n        if (settings.renderGroup) {\r\n            renderGroup = settings.renderGroup;\r\n        }\r\n\r\n        const fragment = doc.createDocumentFragment();\r\n        let prevGroup = \"#9?$\";\r\n\r\n        items.forEach(function(item: T, index: number): void {\r\n            if (item.group && item.group !== prevGroup) {\r\n                prevGroup = item.group;\r\n                const groupDiv = renderGroup(item.group, inputValue);\r\n                if (groupDiv) {\r\n                    groupDiv.className += \" group\";\r\n                    fragment.appendChild(groupDiv);\r\n                }\r\n            }\r\n            const div = render(item, inputValue);\r\n            if (div) {\r\n                div.id = `${containerId}_${index}`;\r\n                div.setAttribute(\"aria-role\", \"option\");\r\n                div.addEventListener(\"click\", function(ev: MouseEvent): void {\r\n                    settings.onSelect(item, input);\r\n                    clear();\r\n                    ev.preventDefault();\r\n                    ev.stopPropagation();\r\n                });\r\n                if (item === selected) {\r\n                    div.className += \" selected\";\r\n                    div.setAttribute(\"aria-selected\", \"true\");\r\n                    input.setAttribute(\"aria-activedescendant\", div.id);\r\n                }\r\n                fragment.appendChild(div);\r\n            }\r\n        });\r\n        container.appendChild(fragment);\r\n        if (items.length < 1) {\r\n            if (settings.emptyMsg) {\r\n                const empty = doc.createElement(\"div\");\r\n                empty.className = \"empty\";\r\n                empty.textContent = settings.emptyMsg;\r\n                container.appendChild(empty);\r\n            } else {\r\n                clear();\r\n                return;\r\n            }\r\n        }\r\n\r\n        attach();\r\n        updatePosition();\r\n\r\n        updateScroll();\r\n    }\r\n\r\n    function updateIfDisplayed(): void {\r\n        if (containerDisplayed()) {\r\n            update();\r\n        }\r\n    }\r\n\r\n    function resizeEventHandler(): void {\r\n        updateIfDisplayed();\r\n    }\r\n\r\n    function scrollEventHandler(e: Event): void {\r\n        if (e.target !== container) {\r\n            updateIfDisplayed();\r\n        } else {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    function keyupEventHandler(ev: KeyboardEvent): void {\r\n        const keyCode = ev.which || ev.keyCode || 0;\r\n\r\n        const ignore = settings.keysToIgnore || [Keys.Up, Keys.Enter, Keys.Esc, Keys.Right, Keys.Left, Keys.Shift, Keys.Ctrl, Keys.Alt, Keys.CapsLock, Keys.WindowsKey, Keys.Tab];\r\n        for (const key of ignore) {\r\n            if (keyCode === key) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (keyCode >= Keys.F1 && keyCode <= Keys.F12 && !settings.keysToIgnore) {\r\n            return;\r\n        }\r\n\r\n        // the down key is used to open autocomplete\r\n        if (keyCode === Keys.Down && containerDisplayed()) {\r\n            return;\r\n        }\r\n\r\n        startFetch(EventTrigger.Keyboard);\r\n    }\r\n\r\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\r\n    function updateScroll(): void {\r\n        const elements = container.getElementsByClassName(\"selected\");\r\n        if (elements.length > 0) {\r\n            let element = elements[0] as HTMLDivElement;\r\n            \r\n            // make group visible\r\n            const previous = element.previousElementSibling as HTMLDivElement;\r\n            if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\r\n                element = previous;\r\n            }\r\n\r\n            if (element.offsetTop < container.scrollTop) {\r\n                container.scrollTop = element.offsetTop;\r\n            } else {\r\n                const selectBottom = element.offsetTop + element.offsetHeight;\r\n                const containerBottom = container.scrollTop + container.offsetHeight;\r\n                if (selectBottom > containerBottom) {\r\n                    container.scrollTop += selectBottom - containerBottom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select the previous item in suggestions\r\n     */\r\n    function selectPrev(): void {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        } else {\r\n            if (selected === items[0]) {\r\n                selected = items[items.length - 1];\r\n            } else {\r\n                for (let i = items.length - 1; i > 0; i--) {\r\n                    if (selected === items[i] || i === 1) {\r\n                        selected = items[i - 1];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select the next item in suggestions\r\n     */\r\n    function selectNext(): void {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        if (!selected || selected === items[items.length - 1]) {\r\n            selected = items[0];\r\n            return;\r\n        }\r\n        for (let i = 0; i < (items.length - 1); i++) {\r\n            if (selected === items[i]) {\r\n                selected = items[i + 1];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function keydownEventHandler(ev: KeyboardEvent): void {\r\n        const keyCode = ev.which || ev.keyCode || 0;\r\n\r\n        if (keyCode === Keys.Up || keyCode === Keys.Down || keyCode === Keys.Esc) {\r\n            const containerIsDisplayed = containerDisplayed();\r\n\r\n            if (keyCode === Keys.Esc) {\r\n                clear();\r\n            } else {\r\n                if (!containerIsDisplayed || items.length < 1) {\r\n                    return;\r\n                }\r\n                keyCode === Keys.Up\r\n                    ? selectPrev()\r\n                    : selectNext();\r\n                update();\r\n            }\r\n\r\n            ev.preventDefault();\r\n            if (containerIsDisplayed) {\r\n                ev.stopPropagation();\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (keyCode === Keys.Enter) {\r\n            if (selected) {\r\n                settings.onSelect(selected, input);\r\n                clear();\r\n            }\r\n    \r\n            if (preventSubmit) {\r\n                ev.preventDefault();\r\n            }\r\n        }\r\n    }\r\n\r\n    function focusEventHandler(): void {\r\n        if (showOnFocus) {\r\n            startFetch(EventTrigger.Focus);\r\n        }\r\n    }\r\n\r\n    function startFetch(trigger: EventTrigger) {\r\n        // If multiple keys were pressed, before we get an update from server,\r\n        // this may cause redrawing autocomplete multiple times after the last key was pressed.\r\n        // To avoid this, the number of times keyboard was pressed will be saved and checked before redraw.\r\n        const savedKeypressCounter = ++keypressCounter;\r\n\r\n        const inputText = input.value;\r\n        const cursorPos = input.selectionStart || 0;\r\n\r\n        if (inputText.length >= minLen || trigger === EventTrigger.Focus) {\r\n            clearDebounceTimer();\r\n            debounceTimer = window.setTimeout(function(): void {\r\n                settings.fetch(inputText, function(elements: T[] | false): void {\r\n                    if (keypressCounter === savedKeypressCounter && elements) {\r\n                        items = elements;\r\n                        inputValue = inputText;\r\n                        selected = (items.length < 1 || disableAutoSelect) ? undefined : items[0];\r\n                        update();\r\n                    }\r\n                }, trigger, cursorPos);\r\n            }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);\r\n        } else {\r\n            clear();\r\n        }\r\n    }\r\n\r\n    function blurEventHandler(): void {\r\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\r\n        setTimeout(() => {\r\n            if (doc.activeElement !== input) {\r\n                clear();\r\n            }\r\n        }, 200);\r\n    }\r\n\r\n    /**\r\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\r\n     */\r\n    container.addEventListener(\"mousedown\", function(evt: Event) {\r\n        evt.stopPropagation();\r\n        evt.preventDefault();\r\n    });\r\n\r\n    /**\r\n     * Fixes #30: autocomplete closes when scrollbar is clicked in IE\r\n     * See: https://stackoverflow.com/a/9210267/13172349\r\n     */\r\n    container.addEventListener(\"focus\", () => input.focus());\r\n\r\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\r\n    function destroy(): void {\r\n        input.removeEventListener(\"focus\", focusEventHandler);\r\n        input.removeEventListener(\"keydown\", keydownEventHandler as EventListenerOrEventListenerObject);\r\n        input.removeEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\r\n        input.removeEventListener(\"blur\", blurEventHandler);\r\n        window.removeEventListener(\"resize\", resizeEventHandler);\r\n        doc.removeEventListener(\"scroll\", scrollEventHandler, true);\r\n        input.removeAttribute(\"aria-role\");\r\n        input.removeAttribute(\"aria-expanded\");\r\n        input.removeAttribute(\"aria-autocomplete\");\r\n        input.removeAttribute(\"aria-controls\");\r\n        input.removeAttribute(\"aria-activedescendant\");\r\n        clearDebounceTimer();\r\n        clear();\r\n    }\r\n\r\n    // setup event handlers\r\n    input.addEventListener(\"keydown\", keydownEventHandler as EventListenerOrEventListenerObject);\r\n    input.addEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\r\n    input.addEventListener(\"blur\", blurEventHandler);\r\n    input.addEventListener(\"focus\", focusEventHandler);\r\n    window.addEventListener(\"resize\", resizeEventHandler);\r\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\r\n\r\n    return {\r\n        destroy\r\n    };\r\n}\r\n"],"names":["settings","doc","document","container","createElement","containerId","id","length","index","getElementById","selected","debounceTimer","containerStyle","style","userAgent","navigator","mobileFirefox","indexOf","debounceWaitMs","preventSubmit","disableAutoSelect","keyUpEventName","items","inputValue","minLen","showOnFocus","keypressCounter","undefined","minLength","input","Error","clearDebounceTimer","window","clearTimeout","containerDisplayed","parentNode","clear","parent","setAttribute","removeChild","update","firstChild","render","item","currentValue","itemElement","textContent","label","renderGroup","groupName","groupDiv","fragment","createDocumentFragment","prevGroup","forEach","group","className","appendChild","div","addEventListener","ev","onSelect","preventDefault","stopPropagation","emptyMsg","empty","body","height","width","offsetWidth","inputRect","maxHeight","calc","customize","docEl","documentElement","clientTop","clientLeft","scrollTop","pageYOffset","scrollLeft","pageXOffset","top","getBoundingClientRect","offsetHeight","left","innerHeight","bottom","updatePosition","elements","getElementsByClassName","element","previous","previousElementSibling","offsetTop","selectBottom","containerBottom","updateScroll","updateIfDisplayed","resizeEventHandler","scrollEventHandler","e","target","keyupEventHandler","keyCode","which","ignore_1","keysToIgnore","_i","startFetch","keydownEventHandler","containerIsDisplayed","i","selectPrev","selectNext","focusEventHandler","trigger","savedKeypressCounter","inputText","value","cursorPos","selectionStart","setTimeout","fetch","blurEventHandler","activeElement","position","evt","focus","destroy","removeEventListener","removeAttribute"],"mappings":"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"}